var searchIndex = JSON.parse('{\
"nekolib":{"doc":"ねこちゃんライブラリ。","i":[[0,"algo","nekolib","アルゴリズムたち。",null,null],[0,"bisect","nekolib::algo","二分探索。",null,null],[5,"bisect","nekolib::algo::bisect","二分探索で境界を探す。",null,[[["fn",8]],["usize",15]]],[0,"extremum","nekolib::algo","三分探索。",null,null],[5,"extremum","nekolib::algo::extremum","三分探索で極値を探す。",null,[[["range",3]]]],[0,"extremum_float","nekolib::algo","三分探索（実数）。",null,null],[5,"extremum_float","nekolib::algo::extremum_float","三分探索で極値を探す。",null,[[["f64",15],["range",3]]]],[0,"minmax","nekolib::algo","スライスの最小値・最大値を求める。",null,null],[5,"minmax","nekolib::algo::minmax","スライスの最小値および最大値を求める。",null,[[],["option",4]]],[5,"minmax_by_key","","キー <code>key</code> …",null,[[],["option",4]]],[5,"minmax_by","","比較関数 <code>compare</code> …",null,[[["fnmut",8]],["option",4]]],[0,"mo","nekolib::algo","Mo\'s algorithm。",null,null],[5,"mo","nekolib::algo::mo","Mo\'s algorithm。",null,[[["vec",3],["usize",15],["option",4]],["vec",3]]],[0,"parallel_bisect","nekolib::algo","並列二分探索。",null,null],[5,"parallel_bisect","nekolib::algo::parallel_bisect","並列二分探索を行う。",null,[[["statefulpred",8],["vec",3]],[["usize",15],["vec",3]]]],[0,"tortoise_hare","nekolib::algo","周期検出。",null,null],[5,"tortoise_hare","nekolib::algo::tortoise_hare","周期検出を行う。",null,[[]]],[0,"window_bisect","nekolib::algo","尺取り法。",null,null],[5,"window_bisect","nekolib::algo::window_bisect","尺取り法で、各始端に対して境界を探す。",null,[[],[["usize",15],["vec",3]]]],[5,"bisect","nekolib::algo","二分探索で境界を探す。",null,[[["fn",8]],["usize",15]]],[5,"extremum","","三分探索で極値を探す。",null,[[["range",3]]]],[5,"extremum_float","","三分探索で極値を探す。",null,[[["f64",15],["range",3]]]],[5,"minmax","","スライスの最小値および最大値を求める。",null,[[],["option",4]]],[5,"minmax_by","","比較関数 <code>compare</code> …",null,[[["fnmut",8]],["option",4]]],[5,"minmax_by_key","","キー <code>key</code> …",null,[[],["option",4]]],[5,"mo","","Mo\'s algorithm。",null,[[["vec",3],["usize",15],["option",4]],["vec",3]]],[5,"parallel_bisect","","並列二分探索を行う。",null,[[["statefulpred",8],["vec",3]],[["usize",15],["vec",3]]]],[5,"tortoise_hare","","周期検出を行う。",null,[[]]],[5,"window_bisect","","尺取り法で、各始端に対して境界を探す。",null,[[],[["usize",15],["vec",3]]]],[0,"ds","nekolib","データ構造たち。",null,null],[0,"disjoint_sparse_table","nekolib::ds","disjoint sparse table。",null,null],[3,"DisjointSparseTable","nekolib::ds::disjoint_sparse_table","disjoint sparse table。",null,null],[0,"foldable_deque","nekolib::ds","fold 可能両端キュー。",null,null],[3,"FoldableDeque","nekolib::ds::foldable_deque","fold 可能両端キュー。",null,null],[11,"new","","",0,[[]]],[0,"foldable_queue","nekolib::ds","fold 可能キュー。",null,null],[3,"FoldableQueue","nekolib::ds::foldable_queue","fold 可能キュー。",null,null],[11,"new","","",1,[[]]],[0,"interval_set","nekolib::ds","区間の集合。",null,null],[3,"IntervalSet","nekolib::ds::interval_set","区間の集合。",null,null],[11,"new","","空集合で初期化する。",2,[[]]],[11,"is_empty","","集合が空であれば <code>true</code> を返す。",2,[[],["bool",15]]],[11,"insert","","区間 <code>r</code> を追加する。",2,[[["rangebounds",8]]]],[11,"remove","","区間 <code>r</code> を削除する。",2,[[["rangebounds",8]]]],[11,"clear","","空集合に戻す。",2,[[]]],[11,"mex","","<code>x</code> …",2,[[],["bound",4]]],[11,"covering","","区間 <code>r</code> を含む区間の両端を返す。",2,[[],["option",4]]],[11,"has_range","","区間 <code>r</code> を含んでいれば <code>true</code> を返す。",2,[[],["bool",15]]],[0,"union_find","nekolib::ds","union-find。",null,null],[3,"UnionFind","nekolib::ds::union_find","union-find。",null,null],[0,"vec_act_segtree","nekolib::ds","<code>Vec</code> ベースの区間作用セグ木。",null,null],[3,"VecActSegtree","nekolib::ds::vec_act_segtree","",null,null],[11,"new","","",3,[[["usize",15]]]],[11,"is_empty","","",3,[[],["bool",15]]],[11,"len","","",3,[[],["usize",15]]],[0,"vec_segtree","nekolib::ds","<code>Vec</code> ベースのセグ木。",null,null],[3,"VecSegtree","nekolib::ds::vec_segtree","<code>Vec</code> ベースのセグ木。",null,null],[11,"new","","",4,[[["usize",15]]]],[11,"is_empty","","",4,[[],["bool",15]]],[11,"len","","",4,[[],["usize",15]]],[3,"DisjointSparseTable","nekolib::ds","disjoint sparse table。",null,null],[3,"FoldableDeque","","fold 可能両端キュー。",null,null],[3,"FoldableQueue","","fold 可能キュー。",null,null],[3,"IntervalSet","","区間の集合。",null,null],[3,"UnionFind","","union-find。",null,null],[3,"VecActSegtree","","",null,null],[3,"VecSegtree","","<code>Vec</code> ベースのセグ木。",null,null],[0,"graph","nekolib","グラフに関するものたち。",null,null],[0,"dijkstra","nekolib::graph","最短距離 (Dijkstra)。",null,null],[5,"dijkstra","nekolib::graph::dijkstra","Dijkstra 法に基づく最短距離。",null,[[["usize",15]],[["vec",3],["option",4]]]],[0,"scc","nekolib::graph","強連結成分分解。",null,null],[5,"scc","nekolib::graph::scc","lowlink に基づく強連結成分分解。",null,[[["usize",15]],[["usize",15],["vec",3]]]],[5,"dijkstra","nekolib::graph","Dijkstra 法に基づく最短距離。",null,[[["usize",15]],[["vec",3],["option",4]]]],[5,"scc","","lowlink に基づく強連結成分分解。",null,[[["usize",15]],[["usize",15],["vec",3]]]],[0,"math","nekolib","数学関連のアルゴリズムたち。",null,null],[0,"modint","nekolib::math","法 $m$ での演算をする。",null,null],[3,"ModInt","nekolib::math::modint","",null,null],[11,"get","","",5,[[],["i64",15]]],[0,"count_prime","nekolib::math","素数の数え上げ。",null,null],[5,"prime_pi","nekolib::math::count_prime","素数の数え上げ。",null,[[["usize",15]],["usize",15]]],[0,"floor_sum","nekolib::math","floor sum。",null,null],[5,"floor_sum","nekolib::math::floor_sum","floor sum。",null,[[["i128",15]],["i128",15]]],[0,"linear_sieve","nekolib::math","線形篩。",null,null],[3,"LinearSieve","nekolib::math::linear_sieve","線形篩。",null,null],[11,"new","","$n$ 以下の自然数に対する篩を用意する。",6,[[["usize",15]]]],[11,"is_prime","","$n$ が素数であれば <code>true</code> を返す。",6,[[["usize",15]],["bool",15]]],[11,"least_factor","","$n$ の最小素因数を返す。",6,[[["usize",15]],[["usize",15],["option",4]]]],[11,"factors","","$n$ の素因数を列挙する。重複あり。",6,[[["usize",15]]]],[11,"primes","","素数を列挙する。",6,[[]]],[5,"prime_pi","nekolib::math","素数の数え上げ。",null,[[["usize",15]],["usize",15]]],[5,"floor_sum","","floor sum。",null,[[["i128",15]],["i128",15]]],[3,"LinearSieve","","線形篩。",null,null],[3,"ModInt","","",null,null],[0,"seq","nekolib","文字列アルゴリズムたち。",null,null],[0,"kmp","nekolib::seq","KMP 法。",null,null],[3,"KmpSearcher","nekolib::seq::kmp","KMP 法 (Knuth–Morris–Pratt algorithm)。",null,null],[11,"occurrences","","",7,[[],["occurrences",3]]],[3,"Occurrences","","",null,null],[0,"suffix_array","nekolib::seq","接尾辞配列。",null,null],[3,"SuffixArray","nekolib::seq::suffix_array","接尾辞配列。",null,null],[11,"search","","パターン検索を行う。",8,[[]]],[11,"into_inner","","自身を消費し、内部表現を返す。",8,[[],[["usize",15],["vec",3]]]],[0,"z_algo","nekolib::seq","Z algorithm。",null,null],[3,"ZSearcher","nekolib::seq::z_algo","Z algorithm。",null,null],[11,"occurrences","","",9,[[],["occurrences",3]]],[3,"Occurrences","","",null,null],[3,"KmpSearcher","nekolib::seq","KMP 法 (Knuth–Morris–Pratt algorithm)。",null,null],[3,"SuffixArray","","接尾辞配列。",null,null],[3,"ZSearcher","","Z algorithm。",null,null],[0,"traits","nekolib","トレイトたち。",null,null],[0,"act","nekolib::traits","区間作用に関するトレイトです。",null,null],[8,"Act","nekolib::traits::act","区間作用を行う。",null,null],[16,"Action","","<code>r</code> で指定される区間に作用を行う。",10,null],[10,"act","","",10,[[]]],[0,"action","nekolib::traits","作用モノイド。",null,null],[8,"MonoidAction","nekolib::traits::action","作用モノイド。",null,null],[16,"Operator","","作用を行う型。",11,null],[16,"Operand","","作用される型。",11,null],[10,"act","","作用を行う。",11,[[]]],[0,"additive","nekolib::traits","加法に関するトレイトたちです。",null,null],[8,"Zero","nekolib::traits::additive","加法の単位元 $0$ を定義する。",null,null],[10,"zero","","加法の単位元 $0$ を返す。",12,[[]]],[8,"AddAssoc","","加法が結合法則を満たすことを示す。",null,null],[8,"AddComm","","加法が交換法則を満たすことを示す。",null,null],[0,"assoc_val","nekolib::traits","型に紐づく値。",null,null],[8,"AssocVal","nekolib::traits::assoc_val","値を返す関数を持つ。",null,null],[10,"get","","",13,[[]]],[0,"binop","nekolib::traits","代数的構造に関するトレイトたちです。",null,null],[8,"Magma","nekolib::traits::binop","マグマ。",null,null],[16,"Set","","集合 $M$ に対応する型。",14,null],[10,"op","","$x \\\\circ y$ を返す。",14,[[]]],[8,"Associative","","結合法則を満たす。",null,null],[8,"Identity","","単位元を持つ。",null,null],[10,"id","","単位元を返す。",15,[[]]],[8,"Commutative","","交換法則を満たす。",null,null],[8,"PartialRecip","","逆元を持つ要素が存在する。",null,null],[10,"partial_recip","","",16,[[],["option",4]]],[8,"Recip","","逆元が常に存在する。",null,null],[11,"recip","","",17,[[]]],[8,"Distributive","","分配法則を満たす。",null,null],[8,"Semigroup","","半群。",null,null],[8,"Monoid","","モノイド。",null,null],[8,"CommutativeMonoid","","可換モノイド。",null,null],[8,"Group","","群。",null,null],[8,"CommutativeGroup","","可換群。",null,null],[8,"Ring","","環。",null,null],[16,"Set","","集合 $R$ に対応する型。",18,null],[16,"Additive","","可換群 $(R, \\\\circ, 0)$ に対応する型。",18,null],[16,"Multiplicative","","モノイド $(R, \\\\ast, 1)$ に対応する型。",18,null],[11,"add","","和 $x \\\\circ y$ を返す。",18,[[]]],[11,"zero","","加法 $\\\\circ$ の単位元 $0$ を返す。",18,[[]]],[11,"neg","","加法 $\\\\circ$ に関する $x$ の逆元 $-x$ …",18,[[]]],[11,"mul","","積 $x \\\\ast y$ を返す。",18,[[]]],[11,"one","","乗法 $\\\\ast$ の単位元 $1$ を返す。",18,[[]]],[8,"CommutativeRing","","可換環。",null,null],[8,"Field","","体。",null,null],[11,"recip","","乗法 $\\\\ast$ における関する $x$ の逆元 …",19,[[]]],[0,"disjoint_set","nekolib::traits","素集合に関するトレイトです。",null,null],[8,"DisjointSet","nekolib::traits::disjoint_set","…",null,null],[10,"new","","集合族を $\\\\{\\\\{0\\\\}, \\\\{1\\\\}, \\\\dots, \\\\{n-1\\\\}\\\\}$ …",20,[[["usize",15]]]],[10,"len","","集合族全体に含まれる要素数 $n$ を返す。",20,[[],["usize",15]]],[11,"is_empty","","集合族が空であれば <code>true</code> を返す。",20,[[],["bool",15]]],[10,"unite","","$u$ を含む集合と $v$ …",20,[[["usize",15]],["bool",15]]],[10,"repr","","$u$ を含む集合の代表元を返す。",20,[[["usize",15]],["usize",15]]],[10,"count","","$u$ を含む集合の要素数を返す。",20,[[["usize",15]],["usize",15]]],[11,"equiv","","$u$ と $v$ が同じ集合に含まれていれば <code>true</code> …",20,[[["usize",15]],["bool",15]]],[11,"subset","","$u$ を含む集合の要素を列挙する。",20,[[["usize",15]],[["usize",15],["vec",3]]]],[0,"elastic_slice","nekolib::traits","",null,null],[8,"ExpandFront","nekolib::traits::elastic_slice","",null,null],[10,"expand_front","","",21,[[]]],[8,"ExpandBack","","",null,null],[10,"expand_back","","",22,[[]]],[8,"ShrinkFront","","",null,null],[10,"shrink_front","","",23,[[]]],[8,"ShrinkBack","","",null,null],[10,"shrink_back","","",24,[[]]],[8,"ElasticSlice","","",null,null],[10,"reset","","",25,[[]]],[10,"full_len","","",25,[[],["usize",15]]],[10,"start","","",25,[[],["usize",15]]],[10,"end","","",25,[[],["usize",15]]],[11,"len","","",25,[[],["usize",15]]],[11,"is_empty","","",25,[[],["bool",15]]],[8,"SliceHash","","",null,null],[16,"Salt","","",26,null],[16,"Hashed","","",26,null],[10,"hash","","",26,[[]]],[0,"fold","nekolib::traits","区間和に関するトレイトです。",null,null],[8,"Fold","nekolib::traits::fold","区間和を求める。",null,null],[16,"Output","","",27,null],[10,"fold","","<code>r</code> で指定される区間の和を返す。",27,[[]]],[0,"fold_bisect","nekolib::traits","区間和の二分探索に関するトレイトたち。",null,null],[8,"FoldBisect","nekolib::traits::fold_bisect","左端を固定したときの境界を求める。",null,null],[10,"fold_bisect","","添字 <code>l</code> と述語 <code>pred</code> …",28,[[["usize",15]]]],[8,"FoldBisectRev","","右端を固定したときの境界を求める。",null,null],[10,"fold_bisect_rev","","添字 <code>r</code> と述語 <code>pred</code> …",29,[[["usize",15]]]],[0,"get_mut","nekolib::traits","",null,null],[8,"GetMut","nekolib::traits::get_mut","",null,null],[16,"Output","","",30,null],[10,"get_mut","","",30,[[["usize",15]],["option",4]]],[0,"max","nekolib::traits","最大元に関するトレイトです。",null,null],[8,"Max","nekolib::traits::max","最大元を持つ。",null,null],[10,"max","","最大元を返す。",31,[[]]],[0,"min","nekolib::traits","最小元に関するトレイトです。",null,null],[8,"Min","nekolib::traits::min","最小元を持つ。",null,null],[10,"min","","最小元を返す。",32,[[]]],[0,"multiplicative","nekolib::traits","乗法に関するトレイトたちです。",null,null],[8,"One","nekolib::traits::multiplicative","乗法の単位元 $1$ を定義する。",null,null],[10,"one","","乗法の単位元 $1$ を返す。",33,[[]]],[8,"MulRecip","","乗法の逆元を定義する。",null,null],[16,"Output","","返り値の型。",34,null],[10,"mul_recip","","乗法における $x$ の逆元 $x^{-1}$ を返す。",34,[[]]],[8,"MulAssoc","","乗法が結合法則を満たすことを示す。",null,null],[8,"MulComm","","乗法が交換法則を満たすことを示す。",null,null],[0,"push_pop","nekolib::traits","",null,null],[8,"Push","nekolib::traits::push_pop","",null,null],[16,"Input","","",35,null],[10,"push","","",35,[[]]],[8,"PushFront","","",null,null],[16,"Input","","",36,null],[10,"push_front","","",36,[[]]],[8,"PushBack","","",null,null],[16,"Input","","",37,null],[10,"push_back","","",37,[[]]],[8,"Pop","","",null,null],[16,"Output","","",38,null],[10,"pop","","",38,[[],["option",4]]],[8,"PopFront","","",null,null],[16,"Output","","",39,null],[10,"pop_front","","",39,[[],["option",4]]],[8,"PopBack","","",null,null],[16,"Output","","",40,null],[10,"pop_back","","",40,[[],["option",4]]],[0,"range_bounds","nekolib::traits","区間に関するトレイトです。",null,null],[8,"StartBounded","nekolib::traits::range_bounds","左側が有界である区間。",null,null],[8,"StartInclusive","","左側が閉である区間。",null,null],[8,"StartUnbounded","","左側が非有界である区間。",null,null],[8,"EndBounded","","右側が有界である区間。",null,null],[8,"EndExclusive","","右側が開である区間。",null,null],[8,"EndInclusive","","右側が閉である区間。",null,null],[8,"EndUnbounded","","右側が非有界である区間。",null,null],[0,"set_value","nekolib::traits","値の代入に関するトレイトです。",null,null],[8,"SetValue","nekolib::traits::set_value","値の代入ができることを示す。",null,null],[16,"Input","","代入される型。",41,null],[10,"set_value","","<code>i</code> で指定される要素に <code>x</code> を代入する。",41,[[]]],[0,"stateful_predicate","nekolib::traits","",null,null],[8,"StatefulPred","nekolib::traits::stateful_predicate","",null,null],[16,"Input","","",42,null],[10,"count","","",42,[[],["usize",15]]],[10,"next","","",42,[[]]],[10,"pred","","",42,[[],["bool",15]]],[10,"reset","","",42,[[]]],[8,"Act","nekolib::traits","区間作用を行う。",null,null],[16,"Action","","<code>r</code> で指定される区間に作用を行う。",10,null],[10,"act","","",10,[[]]],[8,"MonoidAction","","作用モノイド。",null,null],[16,"Operator","","作用を行う型。",11,null],[16,"Operand","","作用される型。",11,null],[10,"act","","作用を行う。",11,[[]]],[8,"AddAssoc","","加法が結合法則を満たすことを示す。",null,null],[8,"AddComm","","加法が交換法則を満たすことを示す。",null,null],[8,"Zero","","加法の単位元 $0$ を定義する。",null,null],[10,"zero","","加法の単位元 $0$ を返す。",12,[[]]],[8,"AssocVal","","値を返す関数を持つ。",null,null],[10,"get","","",13,[[]]],[8,"Associative","","結合法則を満たす。",null,null],[8,"Commutative","","交換法則を満たす。",null,null],[8,"CommutativeGroup","","可換群。",null,null],[8,"CommutativeMonoid","","可換モノイド。",null,null],[8,"CommutativeRing","","可換環。",null,null],[8,"Distributive","","分配法則を満たす。",null,null],[8,"Field","","体。",null,null],[11,"recip","","乗法 $\\\\ast$ における関する $x$ の逆元 …",19,[[]]],[8,"Group","","群。",null,null],[8,"Identity","","単位元を持つ。",null,null],[10,"id","","単位元を返す。",15,[[]]],[8,"Magma","","マグマ。",null,null],[16,"Set","","集合 $M$ に対応する型。",14,null],[10,"op","","$x \\\\circ y$ を返す。",14,[[]]],[8,"Monoid","","モノイド。",null,null],[8,"PartialRecip","","逆元を持つ要素が存在する。",null,null],[10,"partial_recip","","",16,[[],["option",4]]],[8,"Recip","","逆元が常に存在する。",null,null],[11,"recip","","",17,[[]]],[8,"Ring","","環。",null,null],[16,"Set","","集合 $R$ に対応する型。",18,null],[16,"Additive","","可換群 $(R, \\\\circ, 0)$ に対応する型。",18,null],[16,"Multiplicative","","モノイド $(R, \\\\ast, 1)$ に対応する型。",18,null],[11,"add","","和 $x \\\\circ y$ を返す。",18,[[]]],[11,"zero","","加法 $\\\\circ$ の単位元 $0$ を返す。",18,[[]]],[11,"neg","","加法 $\\\\circ$ に関する $x$ の逆元 $-x$ …",18,[[]]],[11,"mul","","積 $x \\\\ast y$ を返す。",18,[[]]],[11,"one","","乗法 $\\\\ast$ の単位元 $1$ を返す。",18,[[]]],[8,"Semigroup","","半群。",null,null],[8,"DisjointSet","","…",null,null],[10,"new","","集合族を $\\\\{\\\\{0\\\\}, \\\\{1\\\\}, \\\\dots, \\\\{n-1\\\\}\\\\}$ …",20,[[["usize",15]]]],[10,"len","","集合族全体に含まれる要素数 $n$ を返す。",20,[[],["usize",15]]],[11,"is_empty","","集合族が空であれば <code>true</code> を返す。",20,[[],["bool",15]]],[10,"unite","","$u$ を含む集合と $v$ …",20,[[["usize",15]],["bool",15]]],[10,"repr","","$u$ を含む集合の代表元を返す。",20,[[["usize",15]],["usize",15]]],[10,"count","","$u$ を含む集合の要素数を返す。",20,[[["usize",15]],["usize",15]]],[11,"equiv","","$u$ と $v$ が同じ集合に含まれていれば <code>true</code> …",20,[[["usize",15]],["bool",15]]],[11,"subset","","$u$ を含む集合の要素を列挙する。",20,[[["usize",15]],[["usize",15],["vec",3]]]],[8,"ElasticSlice","","",null,null],[10,"reset","","",25,[[]]],[10,"full_len","","",25,[[],["usize",15]]],[10,"start","","",25,[[],["usize",15]]],[10,"end","","",25,[[],["usize",15]]],[11,"len","","",25,[[],["usize",15]]],[11,"is_empty","","",25,[[],["bool",15]]],[8,"ExpandBack","","",null,null],[10,"expand_back","","",22,[[]]],[8,"ExpandFront","","",null,null],[10,"expand_front","","",21,[[]]],[8,"ShrinkBack","","",null,null],[10,"shrink_back","","",24,[[]]],[8,"ShrinkFront","","",null,null],[10,"shrink_front","","",23,[[]]],[8,"SliceHash","","",null,null],[16,"Salt","","",26,null],[16,"Hashed","","",26,null],[10,"hash","","",26,[[]]],[8,"Fold","","区間和を求める。",null,null],[16,"Output","","",27,null],[10,"fold","","<code>r</code> で指定される区間の和を返す。",27,[[]]],[8,"FoldBisect","","左端を固定したときの境界を求める。",null,null],[10,"fold_bisect","","添字 <code>l</code> と述語 <code>pred</code> …",28,[[["usize",15]]]],[8,"FoldBisectRev","","右端を固定したときの境界を求める。",null,null],[10,"fold_bisect_rev","","添字 <code>r</code> と述語 <code>pred</code> …",29,[[["usize",15]]]],[8,"GetMut","","",null,null],[16,"Output","","",30,null],[10,"get_mut","","",30,[[["usize",15]],["option",4]]],[8,"Max","","最大元を持つ。",null,null],[10,"max","","最大元を返す。",31,[[]]],[8,"Min","","最小元を持つ。",null,null],[10,"min","","最小元を返す。",32,[[]]],[8,"MulAssoc","","乗法が結合法則を満たすことを示す。",null,null],[8,"MulComm","","乗法が交換法則を満たすことを示す。",null,null],[8,"MulRecip","","乗法の逆元を定義する。",null,null],[16,"Output","","返り値の型。",34,null],[10,"mul_recip","","乗法における $x$ の逆元 $x^{-1}$ を返す。",34,[[]]],[8,"One","","乗法の単位元 $1$ を定義する。",null,null],[10,"one","","乗法の単位元 $1$ を返す。",33,[[]]],[8,"Pop","","",null,null],[16,"Output","","",38,null],[10,"pop","","",38,[[],["option",4]]],[8,"PopBack","","",null,null],[16,"Output","","",40,null],[10,"pop_back","","",40,[[],["option",4]]],[8,"PopFront","","",null,null],[16,"Output","","",39,null],[10,"pop_front","","",39,[[],["option",4]]],[8,"Push","","",null,null],[16,"Input","","",35,null],[10,"push","","",35,[[]]],[8,"PushBack","","",null,null],[16,"Input","","",37,null],[10,"push_back","","",37,[[]]],[8,"PushFront","","",null,null],[16,"Input","","",36,null],[10,"push_front","","",36,[[]]],[8,"EndBounded","","右側が有界である区間。",null,null],[8,"EndExclusive","","右側が開である区間。",null,null],[8,"EndInclusive","","右側が閉である区間。",null,null],[8,"EndUnbounded","","右側が非有界である区間。",null,null],[8,"StartBounded","","左側が有界である区間。",null,null],[8,"StartInclusive","","左側が閉である区間。",null,null],[8,"StartUnbounded","","左側が非有界である区間。",null,null],[8,"SetValue","","値の代入ができることを示す。",null,null],[16,"Input","","代入される型。",41,null],[10,"set_value","","<code>i</code> で指定される要素に <code>x</code> を代入する。",41,[[]]],[8,"StatefulPred","","",null,null],[16,"Input","","",42,null],[10,"count","","",42,[[],["usize",15]]],[10,"next","","",42,[[]]],[10,"pred","","",42,[[],["bool",15]]],[10,"reset","","",42,[[]]],[0,"utils","nekolib","便利ちゃんたち。",null,null],[0,"buf_range","nekolib::utils","配列上の区間に関する関数。",null,null],[5,"bounds_within","nekolib::utils::buf_range","区間を配列サイズに収まるように丸める。",null,[[["rangebounds",8],["usize",15]],[["usize",15],["range",3]]]],[0,"op_add","nekolib::utils","加法に関する wrapper クラス。",null,null],[3,"OpAdd","nekolib::utils::op_add","和を返す演算を持つ。",null,null],[0,"op_max","nekolib::utils","最大値に関する wrapper クラス。",null,null],[3,"OpMax","nekolib::utils::op_max","最大値を返す演算を持つ。",null,null],[0,"op_min","nekolib::utils","最小値に関する wrapper クラス。",null,null],[3,"OpMin","nekolib::utils::op_min","最小値を返す演算を持つ。",null,null],[0,"op_mul","nekolib::utils","乗法に関する wrapper クラス。",null,null],[3,"OpMul","nekolib::utils::op_mul","積を返す演算を持つ。",null,null],[0,"op_roll_hash","nekolib::utils","ローリングハッシュに関する wrapper …",null,null],[3,"OpRollHash","nekolib::utils::op_roll_hash","…",null,null],[11,"val_from","","",43,[[["str",15]]]],[0,"scanner","nekolib::utils","スキャナ。",null,null],[3,"Scanner","nekolib::utils::scanner","スキャナ。",null,null],[11,"from_stdin","","",44,[[],[["result",4],["error",3]]]],[11,"next","","",44,[[],[["result",4],["scan",8]]]],[11,"next_m1","","",44,[[],["result",4]]],[11,"next_n","","",44,[[["usize",15]],[["result",4],["vec",3]]]],[11,"get_while","","",44,[[],["str",15]]],[11,"get_line","","",44,[[],["str",15]]],[11,"ignore","","",44,[[]]],[11,"ignore_while","","",44,[[]]],[8,"Scan","","",null,null],[16,"Err","","",45,null],[10,"scan","","",45,[[["str",15]]]],[3,"ScanTupleError","","",null,null],[5,"bounds_within","nekolib::utils","区間を配列サイズに収まるように丸める。",null,[[["rangebounds",8],["usize",15]],[["usize",15],["range",3]]]],[3,"OpAdd","","和を返す演算を持つ。",null,null],[3,"OpMax","","最大値を返す演算を持つ。",null,null],[3,"OpMin","","最小値を返す演算を持つ。",null,null],[3,"OpMul","","積を返す演算を持つ。",null,null],[3,"OpRollHash","","…",null,null],[3,"Scanner","","スキャナ。",null,null],[14,"impl_mod_int","nekolib","",null,null],[14,"impl_assoc_val","","",null,null],[11,"from","nekolib::ds","",46,[[]]],[11,"into","","",46,[[]]],[11,"borrow","","",46,[[]]],[11,"borrow_mut","","",46,[[]]],[11,"try_from","","",46,[[],["result",4]]],[11,"try_into","","",46,[[],["result",4]]],[11,"type_id","","",46,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",47,[[]]],[11,"into","","",47,[[]]],[11,"borrow","","",47,[[]]],[11,"borrow_mut","","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"try_into","","",47,[[],["result",4]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","nekolib::math","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"to_string","","",5,[[],["string",3]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","nekolib::seq","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","nekolib::seq::kmp","",48,[[]]],[11,"into","","",48,[[]]],[11,"into_iter","","",48,[[]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"try_into","","",48,[[],["result",4]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"from","nekolib::seq","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","nekolib::seq::z_algo","",49,[[]]],[11,"into","","",49,[[]]],[11,"into_iter","","",49,[[]]],[11,"borrow","","",49,[[]]],[11,"borrow_mut","","",49,[[]]],[11,"try_from","","",49,[[],["result",4]]],[11,"try_into","","",49,[[],["result",4]]],[11,"type_id","","",49,[[],["typeid",3]]],[11,"from","nekolib::utils","",50,[[]]],[11,"into","","",50,[[]]],[11,"to_owned","","",50,[[]]],[11,"clone_into","","",50,[[]]],[11,"borrow","","",50,[[]]],[11,"borrow_mut","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"try_into","","",50,[[],["result",4]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"from","","",51,[[]]],[11,"into","","",51,[[]]],[11,"to_owned","","",51,[[]]],[11,"clone_into","","",51,[[]]],[11,"borrow","","",51,[[]]],[11,"borrow_mut","","",51,[[]]],[11,"try_from","","",51,[[],["result",4]]],[11,"try_into","","",51,[[],["result",4]]],[11,"type_id","","",51,[[],["typeid",3]]],[11,"from","","",52,[[]]],[11,"into","","",52,[[]]],[11,"to_owned","","",52,[[]]],[11,"clone_into","","",52,[[]]],[11,"borrow","","",52,[[]]],[11,"borrow_mut","","",52,[[]]],[11,"try_from","","",52,[[],["result",4]]],[11,"try_into","","",52,[[],["result",4]]],[11,"type_id","","",52,[[],["typeid",3]]],[11,"from","","",53,[[]]],[11,"into","","",53,[[]]],[11,"to_owned","","",53,[[]]],[11,"clone_into","","",53,[[]]],[11,"borrow","","",53,[[]]],[11,"borrow_mut","","",53,[[]]],[11,"try_from","","",53,[[],["result",4]]],[11,"try_into","","",53,[[],["result",4]]],[11,"type_id","","",53,[[],["typeid",3]]],[11,"from","","",43,[[]]],[11,"into","","",43,[[]]],[11,"to_owned","","",43,[[]]],[11,"clone_into","","",43,[[]]],[11,"borrow","","",43,[[]]],[11,"borrow_mut","","",43,[[]]],[11,"try_from","","",43,[[],["result",4]]],[11,"try_into","","",43,[[],["result",4]]],[11,"type_id","","",43,[[],["typeid",3]]],[11,"from","","",44,[[]]],[11,"into","","",44,[[]]],[11,"borrow","","",44,[[]]],[11,"borrow_mut","","",44,[[]]],[11,"try_from","","",44,[[],["result",4]]],[11,"try_into","","",44,[[],["result",4]]],[11,"type_id","","",44,[[],["typeid",3]]],[11,"from","nekolib::utils::scanner","",54,[[]]],[11,"into","","",54,[[]]],[11,"to_string","","",54,[[],["string",3]]],[11,"borrow","","",54,[[]]],[11,"borrow_mut","","",54,[[]]],[11,"try_from","","",54,[[],["result",4]]],[11,"try_into","","",54,[[],["result",4]]],[11,"type_id","","",54,[[],["typeid",3]]],[11,"act","nekolib::ds","",3,[[]]],[11,"zero","nekolib::math","",5,[[]]],[11,"op","nekolib::utils","",50,[[]]],[11,"op","","",51,[[]]],[11,"op","","",52,[[]]],[11,"op","","",53,[[]]],[11,"op","","",43,[[]]],[11,"id","","",50,[[]]],[11,"id","","",51,[[]]],[11,"id","","",52,[[]]],[11,"id","","",53,[[]]],[11,"id","","",43,[[]]],[11,"partial_recip","","",50,[[],["option",4]]],[11,"partial_recip","","",53,[[],["option",4]]],[11,"recip","","",50,[[]]],[11,"new","nekolib::ds","",47,[[["usize",15]]]],[11,"len","","",47,[[],["usize",15]]],[11,"unite","","",47,[[["usize",15]],["bool",15]]],[11,"repr","","",47,[[["usize",15]],["usize",15]]],[11,"count","","",47,[[["usize",15]],["usize",15]]],[11,"fold","","",46,[[]]],[11,"fold","","",0,[[["rangefull",3]]]],[11,"fold","","",1,[[["rangefull",3]]]],[11,"fold","","",3,[[]]],[11,"fold","","",4,[[]]],[11,"fold_bisect","","",3,[[["usize",15]]]],[11,"fold_bisect","","",4,[[["usize",15]]]],[11,"fold_bisect_rev","","",3,[[["usize",15]]]],[11,"fold_bisect_rev","","",4,[[["usize",15]]]],[11,"get_mut","","",4,[[["usize",15]],[["option",4],["getmutindex",3]]]],[11,"one","nekolib::math","",5,[[]]],[11,"mul_recip","","",5,[[]]],[11,"push","nekolib::ds","",1,[[]]],[11,"push_front","","",0,[[]]],[11,"push_back","","",0,[[]]],[11,"push_back","","",1,[[]]],[11,"push_back","nekolib::seq","",7,[[]]],[11,"pop","nekolib::ds","",1,[[],["option",4]]],[11,"pop_front","","",0,[[],["option",4]]],[11,"pop_front","","",1,[[],["option",4]]],[11,"pop_back","","",0,[[],["option",4]]],[11,"pop_back","nekolib::seq","",7,[[],[["usize",15],["option",4]]]],[11,"set_value","nekolib::ds","",4,[[["usize",15]]]],[11,"from","","",46,[[["vec",3]]]],[11,"from","","",3,[[["vec",3]]]],[11,"from","","",4,[[["vec",3]]]],[11,"from","nekolib::math","",5,[[["i8",15]]]],[11,"from","","",5,[[["i16",15]]]],[11,"from","","",5,[[["i32",15]]]],[11,"from","","",5,[[["i64",15]]]],[11,"from","","",5,[[["u8",15]]]],[11,"from","","",5,[[["u16",15]]]],[11,"from","","",5,[[["u32",15]]]],[11,"from","","",5,[[["u64",15]]]],[11,"from","nekolib::seq","",7,[[["vec",3]]]],[11,"from","","",8,[[["vec",3]]]],[11,"from","","",8,[[["str",15]]]],[11,"from","","",9,[[["vec",3]]]],[11,"from","nekolib::utils","",44,[[["string",3]]]],[11,"next","nekolib::seq::kmp","",48,[[],["option",4]]],[11,"next","nekolib::seq::z_algo","",49,[[],["option",4]]],[11,"clone","nekolib::ds","",2,[[],["intervalset",3]]],[11,"clone","","",3,[[],["vecactsegtree",3]]],[11,"clone","","",4,[[],["vecsegtree",3]]],[11,"clone","nekolib::math","",5,[[],["modint",3]]],[11,"clone","nekolib::seq","",7,[[],["kmpsearcher",3]]],[11,"clone","","",8,[[],["suffixarray",3]]],[11,"clone","","",9,[[],["zsearcher",3]]],[11,"clone","nekolib::utils","",50,[[],["opadd",3]]],[11,"clone","","",51,[[],["opmax",3]]],[11,"clone","","",52,[[],["opmin",3]]],[11,"clone","","",53,[[],["opmul",3]]],[11,"clone","","",43,[[],["oprollhash",3]]],[11,"default","nekolib::ds","",0,[[]]],[11,"default","","",1,[[]]],[11,"eq","","",2,[[["intervalset",3]],["bool",15]]],[11,"ne","","",2,[[["intervalset",3]],["bool",15]]],[11,"eq","nekolib::math","",5,[[["modint",3]],["bool",15]]],[11,"ne","","",5,[[["modint",3]],["bool",15]]],[11,"eq","nekolib::seq","",7,[[["kmpsearcher",3]],["bool",15]]],[11,"ne","","",7,[[["kmpsearcher",3]],["bool",15]]],[11,"eq","","",8,[[["suffixarray",3]],["bool",15]]],[11,"ne","","",8,[[["suffixarray",3]],["bool",15]]],[11,"eq","","",9,[[["zsearcher",3]],["bool",15]]],[11,"ne","","",9,[[["zsearcher",3]],["bool",15]]],[11,"eq","nekolib::utils","",50,[[["opadd",3]],["bool",15]]],[11,"ne","","",50,[[["opadd",3]],["bool",15]]],[11,"eq","","",51,[[["opmax",3]],["bool",15]]],[11,"ne","","",51,[[["opmax",3]],["bool",15]]],[11,"eq","","",52,[[["opmin",3]],["bool",15]]],[11,"ne","","",52,[[["opmin",3]],["bool",15]]],[11,"eq","","",53,[[["opmul",3]],["bool",15]]],[11,"ne","","",53,[[["opmul",3]],["bool",15]]],[11,"eq","","",43,[[["oprollhash",3]],["bool",15]]],[11,"ne","","",43,[[["oprollhash",3]],["bool",15]]],[11,"eq","nekolib::utils::scanner","",54,[[["scantupleerror",3]],["bool",15]]],[11,"fmt","nekolib::ds","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","nekolib::math","",5,[[["formatter",3]],["result",6]]],[11,"fmt","nekolib::seq","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","nekolib::utils","",50,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",53,[[["formatter",3]],["result",6]]],[11,"fmt","","",43,[[["formatter",3]],["result",6]]],[11,"fmt","nekolib::utils::scanner","",54,[[["formatter",3]],["result",6]]],[11,"fmt","nekolib::math","",5,[[["formatter",3]],["result",6]]],[11,"fmt","nekolib::utils::scanner","",54,[[["formatter",3]],["result",6]]],[11,"div","nekolib::math","",5,[[]]],[11,"sub","","",5,[[]]],[11,"add","","",5,[[]]],[11,"mul","","",5,[[]]],[11,"neg","","",5,[[]]],[11,"add_assign","","",5,[[]]],[11,"sub_assign","","",5,[[]]],[11,"mul_assign","","",5,[[]]],[11,"div_assign","","",5,[[]]],[11,"index","nekolib::ds","",46,[[["usize",15]]]],[11,"index","","",4,[[["usize",15]]]]],"p":[[3,"FoldableDeque"],[3,"FoldableQueue"],[3,"IntervalSet"],[3,"VecActSegtree"],[3,"VecSegtree"],[3,"ModInt"],[3,"LinearSieve"],[3,"KmpSearcher"],[3,"SuffixArray"],[3,"ZSearcher"],[8,"Act"],[8,"MonoidAction"],[8,"Zero"],[8,"AssocVal"],[8,"Magma"],[8,"Identity"],[8,"PartialRecip"],[8,"Recip"],[8,"Ring"],[8,"Field"],[8,"DisjointSet"],[8,"ExpandFront"],[8,"ExpandBack"],[8,"ShrinkFront"],[8,"ShrinkBack"],[8,"ElasticSlice"],[8,"SliceHash"],[8,"Fold"],[8,"FoldBisect"],[8,"FoldBisectRev"],[8,"GetMut"],[8,"Max"],[8,"Min"],[8,"One"],[8,"MulRecip"],[8,"Push"],[8,"PushFront"],[8,"PushBack"],[8,"Pop"],[8,"PopFront"],[8,"PopBack"],[8,"SetValue"],[8,"StatefulPred"],[3,"OpRollHash"],[3,"Scanner"],[8,"Scan"],[3,"DisjointSparseTable"],[3,"UnionFind"],[3,"Occurrences"],[3,"Occurrences"],[3,"OpAdd"],[3,"OpMax"],[3,"OpMin"],[3,"OpMul"],[3,"ScanTupleError"]]},\
"nekolib_verify":{"doc":"<code>nekolib</code> の verify に関するもの。","i":[],"p":[]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);